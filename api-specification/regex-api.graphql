
# ===============================================
# START: Enums

enum requestMode {
  test,
  match,
  replace
}

enum regexErrorType {
  delimiter,
  modifier,
  pattern
}

#  END:  Enums
# ===============================================
# START: Interfaces

interface IapiResponse {
  """Whether or not the request was OK or not"""
  ok: Boolean,
  """Code for response type success/error type"""
  code: Number,
  """List of results for test of each supplied regex"""
  content: [ResponseBody],
  """Human readable description of success/error type"""
  message: string
}

#  END:  Interfaces
# ===============================================
# START: Types

type Delimiters {
  open: String!,
  close: String!,
}

type Regex {
  id: ID!,
  """Regular expression pattern (without delimiters or modifiers"""
  pattern: String!,
  """Regular expression modifiers"""
  modifiers: String!,
  """Regular expression"""
  delimiters: Delimiters
}

type RegexMatchReplace implements Regex {
  id: ID!
  pattern: String!,
  modifiers: String!,
  delimiters: Delimiters,
  """Replacement string/pattern"""
  replace: String!,
  """Whether or not to transform white space escape sequences into their normal white space character equivalents"""
  TransformWhiteSpace: Boolean!
}

type MatchConfig {
  """The maximum Number of characters a captured sub-pattern can be before it is truncated"""
  maxSubMatchLen: Number,
  """The maximum Number of characters the whole matched pattern can be before it is truncated"""
  maxWholeMatchLen: Number
}



# -----------------------------------------------
# START: Request types



type APItestRequest {
  type: requestMode!,
  """List of regexes to be tested for validity"""
  regexes: [Regex]!
}

type APIreplaceRequest implements APItestRequest {
  type: requestMode!,
  """List of regexes to apply to sample strings"""
  regexes: [regexMatchReplace]!,
  """List of sample strings to which regexes are to be applied"""
  sampleStrings: [String]!
}

type APImatchRequest implements APIreplaceRequest {
  type: requestMode!,
  regexes: [regexMatchReplace]!,
  sampleStrings: [String]!
  """Whether or not to apply find/replace sequentially on strings or to apply find/replace to fresh version of original string"""
  chainRegexes: Boolean!,
  """Control how much text is returned for each match"""
  matchConfig: MatchConfig
}



#  END:  Request types
# -----------------------------------------------
# START: Response types




type APIinvalidRequestResponse implements IapiResponse {
  """Whether or not the request was OK or not"""
  ok: false,
  """Code for response type success/error type"""
  code: Number,
  """Error message"""
  content: String!,
  """Human readable description of success/error type"""
  message: string
}

type APItestResponse implements IapiResponse {
  """Whether or not the request was OK or not"""
  ok: true,
  """Code for response type success/error type"""
  code: Number,
  """List of results for test of each supplied regex"""
  content: [TestResponse],
  """Human readable description of success/error type"""
  message: string
}

type APImatchResponse implements IapiResponse {
  ok: true,
  code: Number,
  content: [MatchResponse],
  message: string,
  """Whether or not contents objects include timings for processing of regexes"""
  hasTiming: Boolean
}

type APIreplaceResponse implements IapiResponse {
  ok: true,
  code: Number,
  content: [ReplaceResponse],
  message: string,
  """Whether or not contents objects include timings for processing of regexes"""
  hasTiming: Boolean
}

type APIconfigResponse implements IapiResponse {
  ok: true,
  code: Number,
  content: engineConfig,
  message: string
}

# - - - - - - - - - - - - - - - - - - - - - - - -
# START: Response sub-types

type MatchParts {
  key: String | Number,
  value: String
}

type ResponseCapturedMatches {
  wholeMatch: string,
  parts: [MatchParts],
}

type RegexError {
  """Whether or not the engine was able to fix the error"""
  autoRepair: Boolean!,
  """Which part of the regex does this error relate to"""
  type: regexErrorType!,
  """Message about the given erorr (cleaned up for user interface)"""
  message: String!
  """If there's an issue within the regex pattern. badCharacter is the character at which the issue starts"""
  badCharacter: string,
  """If there's an issue within the regex pattern. offset is the index of the character at which the issue starts"""
  offset: Number,
  """Raw error message generated by regex engine"""
  rawMessage: string,
}

type ResponseRegex {
  id: ID!,
  """Whether or not the regex (as a whole) was valid"""
  isValid: Boolean!,
  """Details about errors in regex"""
  error: [RegexError]
}


type TestResponse {
  regex: ResponseRegex!
}

type MatchResponse implements TestResponse {
  regex: ResponseRegex!,
  """List of matches for a given regex & supplied strings"""
  matches: [ResponseCapturedMatches]!,
  """Number of miliseconds the matching took the engine to execute (if available for that engine/platform)"""
  duration: Number
}

type ReplaceResponse {
  """List of supplied sample strings, transformed by supplied regexes"""
  transformedSamples: [TransformedSample]!
}

type TransformedSample {
  sample: String!,
  duration: Number
}

type EngineConfig {
  modifiers: [String]!,
  delimiters: {
    single: [String]!,
    paired: [Delimiters]!
  }!,
  maxPart: Number,
  maxWhole: Number,
  maxRegexes: Number,
  maxSamples: Number,
  maxSampleLength: Number,
  maxTotalSampleLength: Number,
  maxReturnSampleLength: Number
}

#  END:  Response sub-types
# - - - - - - - - - - - - - - - - - - - - - - - -


#  END:  Response types
# -----------------------------------------------

#  END:  Types
# ===============================================
# START: Unions

union RegexResponses = TestResponse | MatchResponse | ReplaceResponse

union ResponseBody = [RegexResponses] | EngineConfig

#  END:  Unions
# ===============================================
# START: Scalars

#  END:  Scalars
# ===============================================
